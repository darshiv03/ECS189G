# -*- coding: utf-8 -*-
"""stage3

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1UF60lxHDTDJh2Rh5XI_XubHR13mB87s1
"""

import torch
import torch.nn as nn
import torch.nn.functional as F
import torch.optim as optim
from torch.utils.data import Dataset, DataLoader
import pickle
import matplotlib.pyplot as plt
import numpy as np

class ImageDataset(Dataset):
    def __init__(self, data, grayscale=False):
        self.data = data
        self.grayscale = grayscale

    def __len__(self):
        return len(self.data)

    def __getitem__(self, idx):
        image = self.data[idx]['image']
        label = self.data[idx]['label']
        if label > 9:
            label -= 1
        if image.ndim == 3:
            if self.grayscale:
                image = image[:, :, 0]
                image = torch.tensor(image, dtype=torch.float32).unsqueeze(0)
            else:
                image = torch.tensor(image, dtype=torch.float32).permute(2, 0, 1)
        else:
            image = torch.tensor(image, dtype=torch.float32).unsqueeze(0)
        return image, torch.tensor(label, dtype=torch.long)

class CNNModel(nn.Module):
    def __init__(self, input_channels, num_classes, input_size=(28, 28), config='default'):
        super().__init__()
        if config == 'wide':
            self.conv1 = nn.Conv2d(input_channels, 64, 5, padding=2)
            self.conv2 = nn.Conv2d(64, 128, 5, padding=2)
            conv_out_channels = 128
        else:
            self.conv1 = nn.Conv2d(input_channels, 32, 3, padding=1)
            self.conv2 = nn.Conv2d(32, 64, 3, padding=1)
            conv_out_channels = 64

        self.pool = nn.MaxPool2d(2, 2)

        h, w = input_size
        h, w = h // 4, w // 4
        flattened_size = conv_out_channels * h * w

        self.fc1 = nn.Linear(flattened_size, 128 if config == 'default' else 256)
        self.fc2 = nn.Linear(self.fc1.out_features, num_classes)

    def forward(self, x):
        x = self.pool(F.relu(self.conv1(x)))
        x = self.pool(F.relu(self.conv2(x)))
        x = x.view(x.size(0), -1)
        x = F.relu(self.fc1(x))
        return self.fc2(x)

def train_model(model, train_loader, test_loader, epochs=15):
    device = torch.device("cuda" if torch.cuda.is_available() else "cpu")
    model.to(device)
    criterion = nn.CrossEntropyLoss()
    optimizer = optim.Adam(model.parameters(), lr=0.001)
    train_losses = []
    test_accuracies = []
    for epoch in range(epochs):
        model.train()
        loss_epoch = 0
        for imgs, labels in train_loader:
            imgs, labels = imgs.to(device), labels.to(device)
            optimizer.zero_grad()
            outputs = model(imgs)
            loss = criterion(outputs, labels)
            loss.backward()
            optimizer.step()
            loss_epoch += loss.item()
        train_losses.append(loss_epoch)

        model.eval()
        correct, total = 0, 0
        with torch.no_grad():
            for imgs, labels in test_loader:
                imgs, labels = imgs.to(device), labels.to(device)
                outputs = model(imgs)
                _, predicted = torch.max(outputs.data, 1)
                total += labels.size(0)
                correct += (predicted == labels).sum().item()
        acc = 100 * correct / total
        test_accuracies.append(acc)
        print(f"Epoch {epoch+1}: Loss = {loss_epoch:.3f}, Accuracy = {acc:.2f}%")
    return train_losses, test_accuracies

with open("ORL", 'rb') as f: orl_data = pickle.load(f)
with open("CIFAR", 'rb') as f: cifar_data = pickle.load(f)
with open("MNIST", 'rb') as f: mnist_data = pickle.load(f)

orl_train = DataLoader(ImageDataset(orl_data['train'], grayscale=True), batch_size=16, shuffle=True)
orl_test = DataLoader(ImageDataset(orl_data['test'], grayscale=True), batch_size=16, shuffle=False)
mnist_train = DataLoader(ImageDataset(mnist_data['train'], grayscale=True), batch_size=64, shuffle=True)
mnist_test = DataLoader(ImageDataset(mnist_data['test'], grayscale=True), batch_size=64, shuffle=False)
cifar_train = DataLoader(ImageDataset(cifar_data['train']), batch_size=64, shuffle=True)
cifar_test = DataLoader(ImageDataset(cifar_data['test']), batch_size=64, shuffle=False)

print("Training MNIST CNN")
mnist_model = CNNModel(input_channels=1, num_classes=10, input_size=(28, 28))
mnist_losses, mnist_accuracies = train_model(mnist_model, mnist_train, mnist_test)

print("Training ORL CNN")
orl_model = CNNModel(input_channels=1, num_classes=40, input_size=(112, 92), config='wide')
orl_losses, orl_accuracies = train_model(orl_model, orl_train, orl_test)

print("Training CIFAR-10 CNN")
cifar_model = CNNModel(input_channels=3, num_classes=10, input_size=(32, 32))
cifar_losses, cifar_accuracies = train_model(cifar_model, cifar_train, cifar_test)

plt.figure()
plt.plot(mnist_accuracies, label='MNIST')
plt.plot(orl_accuracies, label='ORL')
plt.plot(cifar_accuracies, label='CIFAR-10')
plt.title("Test Accuracy per Epoch")
plt.xlabel("Epoch")
plt.ylabel("Accuracy (%)")
plt.legend()
plt.show()

plt.figure()
plt.plot(mnist_losses, label='MNIST')
plt.plot(orl_losses, label='ORL')
plt.plot(cifar_losses, label='CIFAR-10')
plt.title("Training Loss per Epoch")
plt.xlabel("Epoch")
plt.ylabel("Loss")
plt.legend()
plt.show()

from sklearn.metrics import classification_report
import numpy as np

def evaluate_model(model, test_loader, dataset_name, num_classes):
    device = torch.device("cuda" if torch.cuda.is_available() else "cpu")
    model.eval()
    y_true = []
    y_pred = []

    with torch.no_grad():
        for images, labels in test_loader:
            images, labels = images.to(device), labels.to(device)
            outputs = model(images)
            _, predicted = torch.max(outputs, 1)
            y_true.extend(labels.cpu().numpy())
            y_pred.extend(predicted.cpu().numpy())

    print("Report for {dataset_name}:\n")
    print(classification_report(y_true, y_pred, digits=4, zero_division=0))

evaluate_model(mnist_model, mnist_test, "MNIST", num_classes=10)
evaluate_model(orl_model, orl_test, "ORL", num_classes=40)
evaluate_model(cifar_model, cifar_test, "CIFAR-10", num_classes=10)

plt.figure()
plt.plot(mnist_accuracies, label='MNIST')
plt.plot(orl_accuracies, label='ORL')
plt.plot(cifar_accuracies, label='CIFAR')
plt.title("Test Accuracy (per Epoch)")
plt.xlabel("Epoch")
plt.ylabel("Accuracy (%)")
plt.legend()
plt.show()

plt.figure()
plt.plot(mnist_losses, label='MNIST')
plt.plot(orl_losses, label='ORL')
plt.plot(cifar_losses, label='CIFAR')
plt.title("Training Loss (per Epoch)")
plt.xlabel("Epoch")
plt.ylabel("Loss")
plt.legend()
plt.show()